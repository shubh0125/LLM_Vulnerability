{
    "V_001": {
        "commit_code": {
            "Code": "static long futex_wait_restart(struct restart_block *restart)\n{\n    u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;\n    int fshared = 0;\n    ktime_t t, *tp = NULL;\n\n    if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {\n        t.tv64 = restar\n        t->futex.time;\n        tp = &t;\n    }\n    restart->fn = do_no_restart_syscall;\n    if (restart->futex.flags & FLAGS_SHARED)\n        fshared = 1;\n    return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,\n                            restart->futex.bitset,\n                            restart->futex.flags & FLAGS_CLOCKRT);\n}",
            "Size": 0,
            "Complexity": 0,
            "Memory Management": 0,
            "Code Complexity": 0,
            "Error Handling": 0
        },
        "neutral_code": {
            "Code": "static long futex_wait_restart(struct restart_block *restart)\n{\n    u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;\n    int fshared = 0;\n    ktime_t t, *tp = NULL;\n\n    if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {\n        t.tv64 = restar\n        t->futex.time;\n        tp = &t;\n    }\n    restart->fn = do_no_restart_syscall;\n    if (restart->futex.flags & FLAGS_SHARED)\n        fshared = 1;\n    return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,\n                            restart->futex.bitset,\n                            restart->futex.flags & FLAGS_CLOCKRT);\n}",
            "Size": 0,
            "Complexity": 0,
            "Memory Management": 0,
            "Code Complexity": 0,
            "Error Handling": 0
        }
    },
    "V_002": {
        "commit_code": {
            "Code": "static int\nlookup_pi_state(u32 uval, struct futex_hash_bucket *hb,\n\t\tunion futex_key *key, struct futex_pi_state **ps)\n{\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_q *this, *next;\n\tstruct plist_head *head;\n\tstruct task_struct *p;\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\n\thead = &hb->chain;\n\n\tplist_for_each_entry_safe(this, next, head, list) {\n\t\tif (match_futex(&this->key, key)) {\n\t\t\t/*\n\t\t\t * Another waiter already exists - bump up\n\t\t\t * the refcount and return its pi_state:\n\t\t\t */\n\t\t\tpi_state = this->pi_state;\n\t\t\t/*\n\t\t\t * Userspace might have messed up non PI and PI futexes\n\t\t\t */\n\t\t\tif (unlikely(!pi_state))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tWARN_ON(!atomic_read(&pi_state->refcount));\n\t\t\tWARN_ON(pid && pi_state->owner &&\n\t\t\t\tpi_state->owner->pid != pid);\n\n\t\t\tatomic_inc(&pi_state->refcount);\n\t\t\t*ps = pi_state;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * We are the first waiter - try to look up the real owner and attach\n\t * the new pi_state to it, but bail out when TID = 0\n\t */\n\tif (!pid)\n\t\treturn -ESRCH;\n\tp = futex_find_get_task(pid);\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\t/*\n\t * We need to look at the task state flags to figure out,\n\t * whether the task is exiting. To protect against the do_exit\n\t * change of the task flags, we do this protected by\n\t * p->pi_lock:\n\t */\n\traw_spin_lock_irq(&p->pi_lock);\n\tif (unlikely(p->flags & PF_EXITING)) {\n\t\t/*\n\t\t * The task is on the way out. When PF_EXITPIDONE is\n\t\t * set, we know that the task has finished the\n\t\t * cleanup:\n\t\t */\n\t\tint ret = (p->flags & PF_EXITPIDONE) ? -ESRCH : -EAGAIN;\n\n\t\traw_spin_unlock_irq(&p->pi_lock);\n\t\tput_task_struct(p);\n\t\treturn ret;\n\t}\n\n\tpi_state = alloc_pi_state();\n\n\t/*\n\t * Initialize the pi_mutex in locked state and make 'p'\n\t * the owner of it:\n\t */\n\trt_mutex_init_proxy_locked(&pi_state->pi_mutex, p);\n\n\t/* Store the key for possible exit cleanups: */\n\tpi_state->key = *key;\n\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &p->pi_state_list);\n\tpi_state->owner = p;\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\t*ps = pi_state;\n\n\treturn 0;\n}\n",
            "Size": 0,
            "Complexity": 0,
            "Memory Management": 0,
            "Code Complexity": 0,
            "Error Handling": 0
        },
        "neutral_code": {
            "Code": "static int\nlookup_pi_state(u32 uval, struct futex_hash_bucket *hb,\n\t\tunion futex_key *key, struct futex_pi_state **ps)\n{\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_q *this, *next;\n\tstruct plist_head *head;\n\tstruct task_struct *p;\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\n\thead = &hb->chain;\n\n\tplist_for_each_entry_safe(this, next, head, list) {\n\t\tif (match_futex(&this->key, key)) {\n\t\t\t/*\n\t\t\t * Another waiter already exists - bump up\n\t\t\t * the refcount and return its pi_state:\n\t\t\t */\n\t\t\tpi_state = this->pi_state;\n\t\t\t/*\n\t\t\t * Userspace might have messed up non PI and PI futexes\n\t\t\t */\n\t\t\tif (unlikely(!pi_state))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tWARN_ON(!atomic_read(&pi_state->refcount));\n\t\t\tWARN_ON(pid && pi_state->owner &&\n\t\t\t\tpi_state->owner->pid != pid);\n\n\t\t\tatomic_inc(&pi_state->refcount);\n\t\t\t*ps = pi_state;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * We are the first waiter - try to look up the real owner and attach\n\t * the new pi_state to it, but bail out when TID = 0\n\t */\n\tif (!pid)\n\t\treturn -ESRCH;\n\tp = futex_find_get_task(pid);\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\t/*\n\t * We need to look at the task state flags to figure out,\n\t * whether the task is exiting. To protect against the do_exit\n\t * change of the task flags, we do this protected by\n\t * p->pi_lock:\n\t */\n\traw_spin_lock_irq(&p->pi_lock);\n\tif (unlikely(p->flags & PF_EXITING)) {\n\t\t/*\n\t\t * The task is on the way out. When PF_EXITPIDONE is\n\t\t * set, we know that the task has finished the\n\t\t * cleanup:\n\t\t */\n\t\tint ret = (p->flags & PF_EXITPIDONE) ? -ESRCH : -EAGAIN;\n\n\t\traw_spin_unlock_irq(&p->pi_lock);\n\t\tput_task_struct(p);\n\t\treturn ret;\n\t}\n\n\tpi_state = alloc_pi_state();\n\n\t/*\n\t * Initialize the pi_mutex in locked state and make 'p'\n\t * the owner of it:\n\t */\n\trt_mutex_init_proxy_locked(&pi_state->pi_mutex, p);\n\n\t/* Store the key for possible exit cleanups: */\n\tpi_state->key = *key;\n\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &p->pi_state_list);\n\tpi_state->owner = p;\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\t*ps = pi_state;\n\n\treturn 0;\n}\n\t \n",
            "Size": 0,
            "Complexity": 0,
            "Memory Management": 0,
            "Code Complexity": 0,
            "Error Handling": 0
        }
    },
    "V_003": {
        "commit_code": {
            "Code": "static inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n} \n",
            "Size": 0,
            "Complexity": 0,
            "Memory Management": 0,
            "Code Complexity": 0,
            "Error Handling": 0
        },
        "neutral_code": {
            "Code": "static inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}\n",
            "Size": 0,
            "Complexity": 0,
            "Memory Management": 0,
            "Code Complexity": 0,
            "Error Handling": 0
        }
    },
    "V_004": {
        "commit_code": {
            "Code": "static int refill_pi_state_cache(void)\n{\n\tstruct futex_pi_state *pi_state;\n\n\tif (likely(current->pi_state_cache))\n\t\treturn 0;\n\n\tpi_state = kzalloc(sizeof(*pi_state), GFP_KERNEL);\n\n\tif (!pi_state)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pi_state->list);\n\t/* pi_mutex gets initialized later */\n\tpi_state->owner = NULL;\n\tatomic_set(&pi_state->refcount, 1);\n\tpi_state->key = FUTEX_KEY_INIT;\n\n\tcurrent->pi_state_cache = pi_state;\n\n\treturn 0;\n}\n",
            "Size": 0,
            "Complexity": 0,
            "Memory Management": 0,
            "Code Complexity": 0,
            "Error Handling": 0
        },
        "neutral_code": {
            "Code": "static int refill_pi_state_cache(void)\n{\n\tstruct futex_pi_state *pi_state;\n\n\tif (likely(current->pi_state_cache))\n\t\treturn 0;\n\n\tpi_state = kzalloc(sizeof(*pi_state), GFP_KERNEL);\n\n\tif (!pi_state)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pi_state->list);\n\t/* pi_mutex gets initialized later */\n\tpi_state->owner = NULL;\n\tatomic_set(&pi_state->refcount, 1);\n\tpi_state->key = FUTEX_KEY_INIT;\n\n\tcurrent->pi_state_cache = pi_state;\n\n\treturn 0;\n}\n",
            "Size": 0,
            "Complexity": 0,
            "Memory Management": 0,
            "Code Complexity": 0,
            "Error Handling": 0
        }
    }
}